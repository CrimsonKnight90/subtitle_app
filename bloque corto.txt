 # --- Iniciar traducci√≥n ---
    def _start(self):
        if self.list.count() == 0:
            QMessageBox.warning(self, "‚ö†", self.tr("No hay archivos para traducir"))
            return

        self.completed_tasks = 0  # Reiniciar contador
        self.processing_started.emit()  # Bloquear men√∫ en MainWindow

        # Bloquear todo menos Cancelar
        for w in self._controls_to_lock:
            w.setEnabled(False)
        self.btn_cancel.setEnabled(True)
        self.is_running = True

        # Calcular total de l√≠neas
        self.total_lines = 0
        self.done_lines = 0
        self.file_line_counts = {}
        for i in range(self.list.count()):
            path = self.list.item(i).data(Qt.UserRole)
            entries = load_srt(path)
            self.file_line_counts[path] = len(entries)
            self.total_lines += len(entries)

        self.progress_global.setMaximum(self.total_lines)
        self.progress_global.setValue(0)

        # Idiomas
        src = self.cmb_src.currentData()
        dst = self.cmb_dst.currentData()

        # Auto-detecci√≥n robusta
        if src == "auto":
            first_file = self.list.item(0).data(Qt.UserRole)
            entries = load_srt(first_file)
            src = self.detect_language_from_entries(entries)

        # Si origen y destino son iguales, forzar cambio
        if src == dst:
            dst = "en" if src != "en" else "es"

        # Guardar configuraci√≥n
        S = get_settings()
        S.config["last_src_lang"] = src
        S.config["last_dst_lang"] = dst
        S.save()

        translator = self._make_translator(src, dst)

        self.tasks.clear()
        for i in range(self.list.count()):
            path = self.list.item(i).data(Qt.UserRole)
            out = str(Path(path).with_name(Path(path).stem + f".{dst}.srt"))
            task = TranslateTask(path, translator, src, dst, out, preprocess_fn=self._clean_line)
            task.signals.progress.connect(self._on_progress)
            task.signals.finished.connect(self._on_finished)
            task.signals.error.connect(self._on_error)
            task.signals.translator_used.connect(self._on_translator_used)
            self.tasks[path] = task
            self.pool.start(task)

        self.lbl_status.setText(self.tr("analyzing_files").format(count=len(self.tasks)))

    # --- Progreso, traductor usado, finalizaci√≥n y errores ---
    def _on_progress(self, file, done, total):
        if file in self.file_progress:
            self.file_progress[file].setValue(int((done / total) * 100))
        # Calcular progreso global
        global_done = sum(
            int((self.file_progress[f].value() / 100) * self.file_line_counts.get(f, 0))
            for f in self.file_progress
        )
        self.progress_global.setValue(global_done)

    def _on_translator_used(self, file, provider_name):
        self.lbl_status.setText(
            self.tr(f"Traduciendo {Path(file).name} con {provider_name}")
        )

    def _on_finished(self, file, out_path):
        self.lbl_status.setText(self.tr(f"Completado: {Path(file).name}"))
        self.completed_tasks += 1

        if self.completed_tasks == len(self.tasks):
            # Mostrar m√©tricas
            summary = []
            for t in self.tasks.values():
                for name, data in t.stats.items():
                    summary.append(
                        f"{name}: {data['count']} l√≠neas, {data['errors']} errores, {data['time']:.2f}s"
                    )
            if summary:
                QMessageBox.information(
                    self,
                    self.tr("Resumen de traducci√≥n"),
                    "\n".join(summary)
                )
            self._end_session()

    def _on_error(self, file, msg):
        QMessageBox.critical(self, "‚ùå", self.tr(f"Error en {Path(file).name}:\n{msg}"))
        if file in self.file_progress:
            self.file_progress[file].setValue(100)
        if all(self.file_progress[f].value() == 100 for f in self.file_progress):
            self._end_session()

    def _cancel_all(self):
        for t in self.tasks.values():
            try:
                t.cancel()
            except Exception:
                pass
        self.tasks.clear()
        self.lbl_status.setText(self.t("process_stopped"))
        self._end_session()

    def _end_session(self):
        for w in self._controls_to_lock:
            w.setEnabled(True)
        self.btn_cancel.setEnabled(False)
        self.is_running = False
        self.lbl_status.setText(self.tr("‚úÖ Traducci√≥n finalizada"))
        self.processing_finished.emit()  # Desbloquear men√∫ en MainWindow

    # --- Retraducci√≥n UI ---
    def retranslate_ui(self):
        self.t = get_translator()
        self.btn_add.setText(self.t("add_subtitles"))
        self.btn_start.setText(self.t("start"))
        self.btn_cancel.setText(self.t("cancel"))
        self.btn_add.setToolTip(self.t("add_subtitles"))
        self.btn_start.setToolTip(self.t("translate_subtitles"))
        self.btn_cancel.setToolTip(self.t("process_stopped"))
        self.info_text_label.setText(self.t("videos_drag_hint"))
        self.lbl_status.setText(self.t("ready_to_start"))
        if self.is_running and self.tasks:
            self.lbl_status.setText(self.t("analyzing_files").format(count=len(self.tasks)))
        else:
            self.lbl_status.setText(self.t("ready_to_start"))

        # üîπ Actualizar labels de idioma y proveedor
        self.label_src.setText(self.t("source_lang"))
        self.label_dst.setText(self.t("target_lang"))
        self.label_provider.setText(self.t("translate_subtitles"))

        # üîπ Reconstruir combos con traducciones actualizadas
        src_code = self.cmb_src.currentData()
        dst_code = self.cmb_dst.currentData()

        self.cmb_src.clear()
        self.cmb_dst.clear()
        self.cmb_src.addItem(self.t("auto_detect"), "auto")
        for code in ALLOWED_LANGS:
            nombre = {
                "en": self.t("english"),
                "es": self.t("spanish"),
                "fr": self.t("french"),
            }.get(code, code)
            self.cmb_src.addItem(nombre, code)
            self.cmb_dst.addItem(nombre, code)

        # Restaurar selecci√≥n previa
        idx_src = max(0, self.cmb_src.findData(src_code))
        idx_dst = max(0, self.cmb_dst.findData(dst_code))
        self.cmb_src.setCurrentIndex(idx_src)
        self.cmb_dst.setCurrentIndex(idx_dst)

        # üîπ Reconstruir combos con traducciones actualizadas
        src_code = self.cmb_src.currentData()
        dst_code = self.cmb_dst.currentData()

        self.cmb_src.clear()
        self.cmb_dst.clear()
        self.cmb_src.addItem(self.t("auto_detect"), "auto")
        for code in ALLOWED_LANGS:
            nombre = {
                "en": self.t("english"),
                "es": self.t("spanish"),
                "fr": self.t("french"),
            }.get(code, code)
            self.cmb_src.addItem(nombre, code)
            self.cmb_dst.addItem(nombre, code)

        # Restaurar selecci√≥n previa
        idx_src = max(0, self.cmb_src.findData(src_code))
        idx_dst = max(0, self.cmb_dst.findData(dst_code))
        self.cmb_src.setCurrentIndex(idx_src)
        self.cmb_dst.setCurrentIndex(idx_dst)

